# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gnm
else:
    import _gnm

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def GetUseExceptions(*args):
    r"""GetUseExceptions() -> int"""
    return _gnm.GetUseExceptions(*args)

def _GetExceptionsLocal(*args):
    r"""_GetExceptionsLocal() -> int"""
    return _gnm._GetExceptionsLocal(*args)

def _SetExceptionsLocal(*args):
    r"""_SetExceptionsLocal(int bVal)"""
    return _gnm._SetExceptionsLocal(*args)

def _UseExceptions(*args):
    r"""_UseExceptions()"""
    return _gnm._UseExceptions(*args)

def _DontUseExceptions(*args):
    r"""_DontUseExceptions()"""
    return _gnm._DontUseExceptions(*args)

def _UserHasSpecifiedIfUsingExceptions(*args):
    r"""_UserHasSpecifiedIfUsingExceptions() -> int"""
    return _gnm._UserHasSpecifiedIfUsingExceptions(*args)

class ExceptionMgr(object):
    """
    Context manager to manage Python Exception state
    for GDAL/OGR/OSR/GNM.

    Separate exception state is maintained for each
    module (gdal, ogr, etc), and this class appears independently
    in all of them. This is built in top of calls to the older
    UseExceptions()/DontUseExceptions() functions.

    Example::

        >>> print(gdal.GetUseExceptions())
        0
        >>> with gdal.ExceptionMgr():
        ...     # Exceptions are now in use
        ...     print(gdal.GetUseExceptions())
        1
        >>>
        >>> # Exception state has now been restored
        >>> print(gdal.GetUseExceptions())
        0

    """
    def __init__(self, useExceptions=True):
        """
        Save whether or not this context will be using exceptions
        """
        self.requestedUseExceptions = useExceptions

    def __enter__(self):
        """
        On context entry, save the current GDAL exception state, and
        set it to the state requested for the context

        """
        self.currentUseExceptions = _GetExceptionsLocal()
        _SetExceptionsLocal(self.requestedUseExceptions)
        if ExceptionMgr.__module__ == "osgeo.gdal":
            try:
                from . import gdal_array
            except ImportError:
                gdal_array = None
            if gdal_array:
                gdal_array._SetExceptionsLocal(self.requestedUseExceptions)

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        On exit, restore the GDAL/OGR/OSR/GNM exception state which was
        current on entry to the context
        """
        _SetExceptionsLocal(self.currentUseExceptions)
        if ExceptionMgr.__module__ == "osgeo.gdal":
            try:
                from . import gdal_array
            except ImportError:
                gdal_array = None
            if gdal_array:
                gdal_array._SetExceptionsLocal(self.currentUseExceptions)




def UseExceptions():
    """ Enable exceptions in all GDAL related modules (osgeo.gdal, osgeo.ogr, osgeo.osr, osgeo.gnm).
        Note: prior to GDAL 3.7, this only affected the calling module"""

    try:
        from . import gdal
        gdal._UseExceptions()
    except ImportError:
        pass
    try:
        from . import gdal_array
        gdal_array._UseExceptions()
    except ImportError:
        pass
    try:
        from . import ogr
        ogr._UseExceptions()
    except ImportError:
        pass
    try:
        from . import osr
        osr._UseExceptions()
    except ImportError:
        pass
    try:
        from . import gnm
        gnm._UseExceptions()
    except ImportError:
        pass

def DontUseExceptions():
    """ Disable exceptions in all GDAL related modules (osgeo.gdal, osgeo.ogr, osgeo.osr, osgeo.gnm).
        Note: prior to GDAL 3.7, this only affected the calling module"""

    try:
        from . import gdal
        gdal._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import gdal_array
        gdal_array._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import ogr
        ogr._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import osr
        osr._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import gnm
        gnm._DontUseExceptions()
    except ImportError:
        pass



hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions = False

def _WarnIfUserHasNotSpecifiedIfUsingExceptions():
    from . import gdal
    if not hasattr(gdal, "hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions") and not _UserHasSpecifiedIfUsingExceptions():
        gdal.hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions = True
        import warnings
        warnings.warn(
            "Neither gnm.UseExceptions() nor gnm.DontUseExceptions() has been explicitly called. " +
            "In GDAL 4.0, exceptions will be enabled by default.", FutureWarning)

from . import ogr
from . import osr
GATDijkstraShortestPath = _gnm.GATDijkstraShortestPath

GATKShortestPath = _gnm.GATKShortestPath

GATConnectedComponents = _gnm.GATConnectedComponents

GNM_EDGE_DIR_BOTH = _gnm.GNM_EDGE_DIR_BOTH

GNM_EDGE_DIR_SRCTOTGT = _gnm.GNM_EDGE_DIR_SRCTOTGT

GNM_EDGE_DIR_TGTTOSRC = _gnm.GNM_EDGE_DIR_TGTTOSRC


def CastToNetwork(*args):
    r"""CastToNetwork(MajorObject base) -> Network"""

    _WarnIfUserHasNotSpecifiedIfUsingExceptions()


    return _gnm.CastToNetwork(*args)

def CastToGenericNetwork(*args):
    r"""CastToGenericNetwork(MajorObject base) -> GenericNetwork"""

    _WarnIfUserHasNotSpecifiedIfUsingExceptions()


    return _gnm.CastToGenericNetwork(*args)
class Network(ogr.MajorObject):
    r"""Proxy of C++ GNMNetworkShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnm.delete_Network

    def ReleaseResultSet(self, *args):
        r"""ReleaseResultSet(Network self, Layer layer)"""
        return _gnm.Network_ReleaseResultSet(self, *args)

    def GetVersion(self, *args):
        r"""GetVersion(Network self) -> int"""
        return _gnm.Network_GetVersion(self, *args)

    def GetName(self, *args):
        r"""GetName(Network self) -> char const *"""
        return _gnm.Network_GetName(self, *args)

    def GetFeatureByGlobalFID(self, *args):
        r"""GetFeatureByGlobalFID(Network self, GIntBig GFID) -> Feature"""
        return _gnm.Network_GetFeatureByGlobalFID(self, *args)

    def GetPath(self, *args, **kwargs):
        r"""GetPath(Network self, GIntBig nStartFID, GIntBig nEndFID, GNMGraphAlgorithmType eAlgorithm, char ** options=None) -> Layer"""
        return _gnm.Network_GetPath(self, *args, **kwargs)

    def DisconnectAll(self, *args):
        r"""DisconnectAll(Network self) -> CPLErr"""
        return _gnm.Network_DisconnectAll(self, *args)

    def GetProjection(self, *args):
        r"""GetProjection(Network self) -> char const *"""
        return _gnm.Network_GetProjection(self, *args)

    def GetProjectionRef(self, *args):
        r"""GetProjectionRef(Network self) -> char const *"""
        return _gnm.Network_GetProjectionRef(self, *args)

    def GetFileList(self, *args):
        r"""GetFileList(Network self) -> char **"""
        return _gnm.Network_GetFileList(self, *args)

    def CreateLayer(self, *args, **kwargs):
        r"""CreateLayer(Network self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer"""
        return _gnm.Network_CreateLayer(self, *args, **kwargs)

    def CopyLayer(self, *args, **kwargs):
        r"""CopyLayer(Network self, Layer src_layer, char const * new_name, char ** options=None) -> Layer"""
        return _gnm.Network_CopyLayer(self, *args, **kwargs)

    def DeleteLayer(self, *args):
        r"""DeleteLayer(Network self, int index) -> OGRErr"""
        return _gnm.Network_DeleteLayer(self, *args)

    def GetLayerCount(self, *args):
        r"""GetLayerCount(Network self) -> int"""
        return _gnm.Network_GetLayerCount(self, *args)

    def GetLayerByIndex(self, *args):
        r"""GetLayerByIndex(Network self, int index=0) -> Layer"""
        return _gnm.Network_GetLayerByIndex(self, *args)

    def GetLayerByName(self, *args):
        r"""GetLayerByName(Network self, char const * layer_name) -> Layer"""
        return _gnm.Network_GetLayerByName(self, *args)

    def TestCapability(self, *args):
        r"""TestCapability(Network self, char const * cap) -> bool"""
        return _gnm.Network_TestCapability(self, *args)

    def StartTransaction(self, *args, **kwargs):
        r"""StartTransaction(Network self, int force=FALSE) -> OGRErr"""
        return _gnm.Network_StartTransaction(self, *args, **kwargs)

    def CommitTransaction(self, *args):
        r"""CommitTransaction(Network self) -> OGRErr"""
        return _gnm.Network_CommitTransaction(self, *args)

    def RollbackTransaction(self, *args):
        r"""RollbackTransaction(Network self) -> OGRErr"""
        return _gnm.Network_RollbackTransaction(self, *args)

# Register Network in _gnm:
_gnm.Network_swigregister(Network)
class GenericNetwork(Network):
    r"""Proxy of C++ GNMGenericNetworkShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnm.delete_GenericNetwork

    def ConnectFeatures(self, *args):
        r"""ConnectFeatures(GenericNetwork self, GIntBig nSrcFID, GIntBig nTgtFID, GIntBig nConFID, double dfCost, double dfInvCost, GNMDirection eDir) -> CPLErr"""
        return _gnm.GenericNetwork_ConnectFeatures(self, *args)

    def DisconnectFeatures(self, *args):
        r"""DisconnectFeatures(GenericNetwork self, GIntBig nSrcFID, GIntBig nTgtFID, GIntBig nConFID) -> CPLErr"""
        return _gnm.GenericNetwork_DisconnectFeatures(self, *args)

    def DisconnectFeaturesWithId(self, *args):
        r"""DisconnectFeaturesWithId(GenericNetwork self, GIntBig nFID) -> CPLErr"""
        return _gnm.GenericNetwork_DisconnectFeaturesWithId(self, *args)

    def ReconnectFeatures(self, *args):
        r"""ReconnectFeatures(GenericNetwork self, GIntBig nSrcFID, GIntBig nTgtFID, GIntBig nConFID, double dfCost, double dfInvCost, GNMDirection eDir) -> CPLErr"""
        return _gnm.GenericNetwork_ReconnectFeatures(self, *args)

    def CreateRule(self, *args):
        r"""CreateRule(GenericNetwork self, char const * pszRuleStr) -> CPLErr"""
        return _gnm.GenericNetwork_CreateRule(self, *args)

    def DeleteAllRules(self, *args):
        r"""DeleteAllRules(GenericNetwork self) -> CPLErr"""
        return _gnm.GenericNetwork_DeleteAllRules(self, *args)

    def DeleteRule(self, *args):
        r"""DeleteRule(GenericNetwork self, char const * pszRuleStr) -> CPLErr"""
        return _gnm.GenericNetwork_DeleteRule(self, *args)

    def GetRules(self, *args):
        r"""GetRules(GenericNetwork self) -> char **"""
        return _gnm.GenericNetwork_GetRules(self, *args)

    def ConnectPointsByLines(self, *args, **kwargs):
        r"""ConnectPointsByLines(GenericNetwork self, char ** papszLayerList, double dfTolerance, double dfCost, double dfInvCost, GNMDirection eDir) -> CPLErr"""
        return _gnm.GenericNetwork_ConnectPointsByLines(self, *args, **kwargs)

    def ChangeBlockState(self, *args):
        r"""ChangeBlockState(GenericNetwork self, GIntBig nFID, bool bIsBlock) -> CPLErr"""
        return _gnm.GenericNetwork_ChangeBlockState(self, *args)

    def ChangeAllBlockState(self, *args):
        r"""ChangeAllBlockState(GenericNetwork self, bool bIsBlock=False) -> CPLErr"""
        return _gnm.GenericNetwork_ChangeAllBlockState(self, *args)

# Register GenericNetwork in _gnm:
_gnm.GenericNetwork_swigregister(GenericNetwork)

