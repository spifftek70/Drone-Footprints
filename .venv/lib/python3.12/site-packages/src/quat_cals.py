import math
import utm
from geographiclib.geodesic import Geodesic


# Quaternion class for handling rotations
class Quaternion:
    def __init__(self, w, x, y, z):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    @staticmethod
    def from_euler(roll, pitch, yaw):
        cy = math.cos(yaw * 0.5)
        sy = math.sin(yaw * 0.5)
        cr = math.cos(roll * 0.5)
        sr = math.sin(roll * 0.5)
        cp = math.cos(pitch * 0.5)
        sp = math.sin(pitch * 0.5)

        w = cy * cr * cp + sy * sr * sp
        x = cy * sr * cp - sy * cr * sp
        y = cy * cr * sp + sy * sr * cp
        z = sy * cr * cp - cy * sr * sp

        return Quaternion(w, x, y, z)

    def multiply(self, other):
        w = self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z
        x = self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y
        y = self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x
        z = self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w

        return Quaternion(w, x, y, z)

    def to_euler(self):
        t0 = +2.0 * (self.w * self.x + self.y * self.z)
        t1 = +1.0 - 2.0 * (self.x * self.x + self.y * self.y)
        roll_x = math.atan2(t0, t1)

        t2 = +2.0 * (self.w * self.y - self.z * self.x)
        t2 = +1.0 if t2 > +1.0 else t2
        t2 = -1.0 if t2 < -1.0 else t2
        pitch_y = math.asin(t2)

        t3 = +2.0 * (self.w * self.z + self.x * self.y)
        t4 = +1.0 - 2.0 * (self.y * self.y + self.z * self.z)
        yaw_z = math.atan2(t3, t4)

        return roll_x, pitch_y, yaw_z


def deg_to_rad(deg):
    return deg * math.pi / 180


def calculate_footprint(FOVh, FOVv, altitude, gimbal_roll_deg, gimbal_pitch_deg, gimbal_yaw_deg, drone_latitude,
                        drone_longitude):
    # Convert angles from degrees to radians
    gimbal_roll = deg_to_rad(gimbal_roll_deg)
    gimbal_pitch = deg_to_rad(gimbal_pitch_deg)
    gimbal_yaw = deg_to_rad(gimbal_yaw_deg)

    # Create quaternions for drone and gimbal orientations
    # drone_orientation = Quaternion.from_euler(drone_roll, drone_pitch, drone_yaw)
    gimbal_orientation = Quaternion.from_euler(gimbal_roll, gimbal_pitch, gimbal_yaw)

    # Combine orientations to find the effective camera orientation
    # camera_orientation = drone_orientation.multiply(gimbal_orientation)

    # Calculate footprint dimensions based on altitude and FOV
    width = 2 * altitude * math.tan(deg_to_rad(FOVh / 2))
    height = 2 * altitude * math.tan(deg_to_rad(FOVv / 2))

    # Convert camera orientation back to Euler angles for direction calculation
    _, pitch, yaw = gimbal_orientation.to_euler()

    # Calculate the footprint's corner points based on the camera's direction and the footprint dimensions
    geod = Geodesic.WGS84
    center_point = (drone_latitude, drone_longitude)
    corners = []
    directions = [yaw + math.pi / 4, yaw + 3 * math.pi / 4, yaw - 3 * math.pi / 4, yaw - math.pi / 4]
    for dir in directions:
        endpoint = geod.Direct(drone_latitude, drone_longitude, math.degrees(dir),
                               math.sqrt((width / 2) ** 2 + (height / 2) ** 2))
        corners.append((endpoint['lat2'], endpoint['lon2']))

    # Return the calculated corner points
    return corners

#
# # Example usage
# FOVh = 90  # Horizontal field of view in degrees
# FOVv = 60  # Vertical field of view in degrees
# altitude = 100  # Altitude in meters
# gimbal_roll_deg = 0
# gimbal_pitch_deg = -90  # Assuming directly downwards
# gimbal_yaw_deg = 0
# drone_roll_deg = 0
# drone_pitch_deg = 0
# drone_yaw_deg = 45  # Assuming north-east direction
# drone_latitude = 37.7749  # Example latitude
# drone_longitude = -122.4194  # Example longitude
#
# footprint_corners = calculate_footprint(FOVh, FOVv, altitude, gimbal_roll_deg, gimbal_pitch_deg, gimbal_yaw_deg,
#                                         drone_roll_deg, drone_pitch_deg, drone_yaw_deg, drone_latitude, drone_longitude)
# print("Image Footprint Corners (Lat, Lon):", footprint_corners)
